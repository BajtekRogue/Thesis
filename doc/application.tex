
\section{Basic Extrema Propagation}

Wyniki i ustalenia modelu \textbf{SI} możemy wykorzystać dla analizy teoretycznej różnych metod propagacji.
Skoncentrujmy naszą uwagę na algorytmie Basic Extrema Propagation, \textbf{BEP} (\ref{algo:BEP}).

\begin{algorithm}
\caption{Basic Extrema Propagation}
\begin{algorithmic}[1]  
\State\textbf{Input:} Graph $G=(V,E)$,  random function $\text{Rand}$, number of steps $T$
\State\textbf{Output:} Values ${(M_v)}_{v\in V}$
\For{$v \in V$}
    \State$M_v \gets \text{Rand}()$ 
\EndFor%
\For{$i=1,2,\ldots,T$}
    \For{$v \in V$}
        \State\text{send} $M_v$ \text{to every} $u\in\text{N}(v)$
        \State\text{receive} $M_u$ \text{from every} $u\in\text{N}(v)$
        \State$M_{v} \gets \min\{M_{v}, \{M_u : u \in \text{N}(v)\}\}$
    \EndFor%
\EndFor%
\State\textbf{return} ${(M_v)}_{v\in V}$
\end{algorithmic}%
\label{algo:BEP}
\end{algorithm}

Jest to algorytm rozproszony zaprojektowany do obliczania wartości ekstremalnych (np.\ minimalnych lub maksymalnych) w sieciach przy użyciu wyłącznie lokalnych interakcji wierzchołków.
Algorytm ten działa następująco:
Każdy wierzchołek ustala wartość początkową losowo, korzystając z funkcji $\mathrm{Rand}$.
Następnie w synchronicznych rundach węzły przesyłają aktualnie przechowywaną wartość do swoich sąsiadów.
Potem odbierają wszystkie wysłane im wartości i obliczają minimum z nich oraz już posiadanej wartości.
Proces ten po pewnym czasie stabilizuje się, to jest każdy wierzchołek posiada tą samą wartość i dalsza propagacja nie ma sensu.
Wtedy algorytm kończy działanie. 
Jeśli wierzchołki mają początkowo wartości ${(M_v)}_{v\in V}$ to zwrócona wartość wynosi $M=\min_{v\in V} M_v$.
Możemy oczywiście założyć, że ${(M_v)}_{v\in V}$ są niezależne.
Dobierając odpowiedni rozkład początkowy wierzchołków możemy w wyniku algorytmu uzyskać różne interesujące wartości.
Przykładowo dla $M_v\sim\mathcal{U}[0;1]$ mamy $\mathbb{E}[M]=\frac{1}{1+|V|}$ (\cref{fact:min_of_uniforms}).
Daje nam to możliwość łatwego oszacowania wielkości sieci.
Gdy zaś $M_v\sim\mathrm{Exp}(\lambda_v)$ to wtedy $M\sim\mathrm{Exp}(\Lambda)$ gdzie $\Lambda=\sum_{v\in V}\lambda_v$ (\cref{facf:min_of_exponentials}).
Ponadto $\mathbb{E}[M]=\frac{1}{\Lambda}$.
Tego rozkładu startowego możemy użyć jeśli chcemy wyłuskać sumę pewnych parametrów przechowywanych w węzłach sieci.
Główną zaletą tej techniki jest jej szybkość.
Skuteczność i dokładność są drugorzędne.
Interesuje nas więc czas działania algorytmu \textbf{BEP}.
Każda runda zajmuje czas rzędu $\mathcal{O}(|E|)$ a więc całkowity czas działania wynosi $\mathcal{O}(T|E|)$.
Musimy wiedzieć, jakie $T$ wybrać żeby uzyskać sensowny wynik.
Górne ograniczenie to $T\le \text{diam}(G)$.
Stabilizacja wartości przechowywanej w $v\in V$ nastąpi, kiedy $v$ prześle informacje do najdalej oddalonego od niego wierzchołka, to jest po $\epsilon(v)$ rundach.
Oczywiście cały proces zakończy się po najdłuższym z tych czasów.
A zatem algorytm po co najwyżej $\mathrm{diam}(G)$ rundach kończy działanie.
W teoretycznym modelu każde przesłanie wiadomości zawsze się powiedzie.
W praktyce natomiast ze względu na szumy i zakłócenia komunikacji przesłanie wiadomości nie zawsze się udaje.
Możemy założyć, że prawdopodobieństwo przesłania informacji w pojedynczej rundzie wynosi $p$.
Krok aktualizacji wartości jest analogiczny do rozprzestrzeniania się infekcji w modelu \textbf{SI}.
Dla ustalonego $s\in V$ zmienne losowe, które zdefiniowaliśmy dostarczają nam sporo informacji o przebiegu algorytmu \textbf{BEP}.
Najistotniejsza jest zmienna $Z$, która jest górnym ograniczeniem na czas zakończenia propagacji.
Możemy więc przyjąć $T=\mathbb{E}[Z]$.
Można pokazać~\cite{OnMessageComplexityOfExtremaPropagationTechniques}, że w dowolnym grafie średnia liczba wiadomości wysłanych przez dowolny wierzchołek podczas całego procesu jest rzędu $\mathcal{O}(\log(|V|))$.